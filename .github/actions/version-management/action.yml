name: 'Version Management'
description: 'Calculate version and determine if this is a release build based on Git history and Maven configuration'
author: 'Eaton'

inputs:
  java-version:
    description: 'Java version to use for the build'
    required: false
    default: '17'

  maven-options:
    description: 'Additional Maven options for version calculation'
    required: false
    default: ''

  auto-tag:
    description: 'Whether to automatically create Git tags for release builds'
    required: false
    default: 'true'

outputs:
  version:
    description: 'Calculated version for the build'
    value: ${{ steps.version-calc.outputs.version }}

  is-release:
    description: 'Whether this is a release build'
    value: ${{ steps.version-calc.outputs.is-release }}

  maven-version:
    description: 'Version from Maven POM file'
    value: ${{ steps.version-calc.outputs.maven-version }}

  git-tag:
    description: 'Latest Git tag if available'
    value: ${{ steps.version-calc.outputs.git-tag }}

  build-number:
    description: 'Build number based on commit count'
    value: ${{ steps.version-calc.outputs.build-number }}

  semantic-version:
    description: 'Semantic version with build metadata'
    value: ${{ steps.version-calc.outputs.semantic-version }}

  tag-created:
    description: 'Whether a new Git tag was created'
    value: ${{ steps.create-tag.outputs.tag-created }}

  tag-name:
    description: 'Name of the Git tag that was created or would be created'
    value: ${{ steps.create-tag.outputs.tag-name }}

runs:
  using: 'composite'
  steps:
    - name: Set up JDK
      uses: actions/setup-java@v4
      with:
        distribution: 'temurin'
        java-version: ${{ inputs.java-version }}
        cache: maven

    - name: Calculate version
      id: version-calc
      shell: bash
      run: |
        # Helper functions
        get_base_version() {
          local latest_tag=$(git tag -l "v*.*.*" --sort=-version:refname | head -n 1)
          if [ -z "$latest_tag" ]; then
            echo "No version tags found matching v*.*.* pattern, using default version 1.0.0" >&2
            echo "1.0.0"
          else
            local base_version=$(echo $latest_tag | sed 's/^v//')
            echo "Found latest version tag: $latest_tag -> base version: $base_version" >&2
            echo "$base_version"
          fi
        }
        
        get_branch_info() {
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "Pull request detected:" >&2
            echo "  Source branch: ${{ github.head_ref }}" >&2
            echo "  Target branch: ${{ github.base_ref }}" >&2
            echo "${{ github.head_ref }}|${{ github.base_ref }}|${{ github.base_ref }}"
          else
            echo "Using current branch: ${{ github.ref_name }}" >&2
            echo "${{ github.ref_name }}||${{ github.ref_name }}"
          fi
        }
        
        extract_release_version() {
          local branch="$1"
          if [[ "$branch" =~ ^release/([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
            echo "${BASH_REMATCH[1]}|${BASH_REMATCH[2]}|${BASH_REMATCH[3]}"
          else
            echo "||"
          fi
        }
        
        increment_version() {
          local base_version="$1"
          local increment_type="$2"
          local release_major="$3"
          local release_minor="$4"
          
          IFS='.' read -r major minor patch <<< "$base_version"
          
          case "$increment_type" in
            "minor_from_release")
              echo "${release_major}.$((release_minor + 1)).0"
              ;;
            "minor")
              echo "${major}.$((minor + 1)).0"
              ;;
            "patch")
              echo "${major}.${minor}.$((patch + 1))"
              ;;
            *)
              echo "$base_version"
              ;;
          esac
        }
        
        build_version_suffix() {
          local suffix_type="$1"
          local pr_number="$2"
          local extra="$3"
          
          case "$suffix_type" in
            "pr")
              echo "-pr.${pr_number}"
              ;;
            "final_pr")
              echo "-final.pr.${pr_number}"
              ;;
            "hotfix_pr")
              echo "-hotfix.pr.${pr_number}"
              ;;
            "rc")
              echo "-rc.${extra}"
              ;;
            "dev")
              echo "-dev.${extra}"
              ;;
            "hotfix")
              echo "-hotfix.${extra}"
              ;;
            "branch_pr")
              echo "-${extra}.pr.${pr_number}"
              ;;
            "branch")
              echo "-${extra}"
              ;;
            *)
              echo ""
              ;;
          esac
        }
        
        # Main logic
        BASE_VERSION=$(get_base_version)
        IFS='|' read -r SOURCE_BRANCH TARGET_BRANCH BRANCH_NAME <<< "$(get_branch_info)"
        
        IS_RELEASE="false"
        VERSION=""
        
        # Determine the working branch (target branch for PRs, current branch otherwise)
        WORKING_BRANCH="$TARGET_BRANCH"
        [[ -z "$WORKING_BRANCH" ]] && WORKING_BRANCH="$BRANCH_NAME"
        
        # Process based on target branch and source branch type
        if [[ "$WORKING_BRANCH" == "main" ]]; then
          IS_RELEASE="true"
          
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            if [[ "$SOURCE_BRANCH" =~ ^release/.* ]]; then
              # Release to main PR
              IFS='|' read -r rel_major rel_minor rel_patch <<< "$(extract_release_version "$SOURCE_BRANCH")"
              if [[ -n "$rel_major" && -n "$rel_minor" ]]; then
                VERSION=$(increment_version "$BASE_VERSION" "minor_from_release" "$rel_major" "$rel_minor")
                echo "Release to main PR detected - using major $rel_major from release branch, incrementing minor"
              else
                VERSION=$(increment_version "$BASE_VERSION" "minor")
                echo "Release to main PR detected - incrementing minor version from base"
              fi
              
            elif [[ "$SOURCE_BRANCH" =~ ^hotfix/.* ]]; then
              # Hotfix branch handling (based on source branch type)
              base_version=$(increment_version "$BASE_VERSION" "patch")
              
              if [[ "${{ github.event_name }}" == "pull_request" ]]; then
                VERSION="${base_version}$(build_version_suffix "hotfix_pr" "${{ github.event.pull_request.number }}")"
              else
                commit_hash=$(git rev-parse --short HEAD)
                VERSION="${base_version}$(build_version_suffix "hotfix" "" "$commit_hash")"
              fi
              
            else
              # Other branch to main PR - patch increment
              VERSION=$(increment_version "$BASE_VERSION" "patch")
            fi
          else
            # Regular main branch push
            VERSION=$(increment_version "$BASE_VERSION" "patch")
          fi
          
        elif [[ "$SOURCE_BRANCH" =~ ^release/.* ]]; then
          # Release branch handling (based on source branch type)
          if [[ "$SOURCE_BRANCH" =~ ^release/([0-9]+\.[0-9]+\.[0-9]+)$ ]]; then
            release_version="${BASH_REMATCH[1]}"
            echo "Using version from release branch name: $release_version"
            
            if [[ "${{ github.event_name }}" == "pull_request" && "$TARGET_BRANCH" == "main" ]]; then
              # Release to main PR
              IFS='|' read -r rel_major rel_minor rel_patch <<< "$(extract_release_version "$SOURCE_BRANCH")"
              if [[ -n "$rel_major" && -n "$rel_minor" ]]; then
                base_version=$(increment_version "$BASE_VERSION" "minor_from_release" "$rel_major" "$rel_minor")
                VERSION="${base_version}$(build_version_suffix "final_pr" "${{ github.event.pull_request.number }}")"
              else
                base_version=$(increment_version "$BASE_VERSION" "minor")
                VERSION="${base_version}$(build_version_suffix "final_pr" "${{ github.event.pull_request.number }}")"
              fi
            elif [[ "${{ github.event_name }}" == "pull_request" ]]; then
              # PR to release branch
              VERSION="${release_version}$(build_version_suffix "pr" "${{ github.event.pull_request.number }}")"
            else
              # Direct push to release branch
              rc_number=$(git rev-list --count HEAD)
              VERSION="${release_version}$(build_version_suffix "rc" "" "$rc_number")"
            fi
          else
            # Release branch without version in name
            rc_number=$(git rev-list --count HEAD)
            VERSION="${BASE_VERSION}$(build_version_suffix "rc" "" "$rc_number")"
          fi
          
        elif [[ "$WORKING_BRANCH" == "develop" ]]; then
          # Develop branch
          build_number=$(git rev-list --count HEAD)
          VERSION="${BASE_VERSION}$(build_version_suffix "dev" "" "$build_number")"
          
        else
          # Feature and other branches
          commit_hash=$(git rev-parse --short HEAD)
          clean_branch_name=$(echo "$WORKING_BRANCH" | sed 's/[^a-zA-Z0-9]/-/g')
          
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            pr_number="${{ github.event.pull_request.number }}"
            clean_target=$(echo "$TARGET_BRANCH" | sed 's/[^a-zA-Z0-9]/-/g')
            
            if [[ "$TARGET_BRANCH" == "main" ]]; then
              clean_source_name=$(echo "$SOURCE_BRANCH" | sed 's/[^a-zA-Z0-9]/-/g')
              VERSION="${BASE_VERSION}$(build_version_suffix "branch_pr" "$pr_number" "${clean_source_name}.to-main")"
            elif [[ "$TARGET_BRANCH" == "develop" ]]; then
              clean_source_name=$(echo "$SOURCE_BRANCH" | sed 's/[^a-zA-Z0-9]/-/g')
              VERSION="${BASE_VERSION}$(build_version_suffix "branch_pr" "$pr_number" "${clean_source_name}.to-dev")"
            elif [[ "$TARGET_BRANCH" =~ ^release/.* ]]; then
              clean_source_name=$(echo "$SOURCE_BRANCH" | sed 's/[^a-zA-Z0-9]/-/g')
              VERSION="${BASE_VERSION}$(build_version_suffix "branch_pr" "$pr_number" "${clean_source_name}.to-release")"
            else
              clean_source_name=$(echo "$SOURCE_BRANCH" | sed 's/[^a-zA-Z0-9]/-/g')
              VERSION="${BASE_VERSION}$(build_version_suffix "branch_pr" "$pr_number" "${clean_source_name}.to-${clean_target}")"
            fi
          else
            VERSION="${BASE_VERSION}$(build_version_suffix "branch" "" "${clean_branch_name}.${commit_hash}")"
          fi
        fi
        
        echo "Calculated version: $VERSION"
        
        # Get Maven version from pom.xml for additional output
        MAVEN_VERSION=""
        if [ -f "pom.xml" ]; then
          MAVEN_VERSION=$(mvn help:evaluate -Dexpression=project.version -q -DforceStdout ${{ inputs.maven-options }})
          echo "Maven version: $MAVEN_VERSION"
        else
          echo "No pom.xml found"
        fi
        
        # Get latest Git tag for additional output
        GIT_TAG=""
        if git describe --tags --abbrev=0 2>/dev/null; then
          GIT_TAG=$(git describe --tags --abbrev=0)
          echo "Latest Git tag: $GIT_TAG"
        else
          echo "No Git tags found"
        fi
        
        # Get commit count for build number
        BUILD_NUMBER=$(git rev-list --count HEAD)
        echo "Build number (commit count): $BUILD_NUMBER"
        
        # Create semantic version with build metadata
        SEMANTIC_VERSION="$VERSION"
        if [ "$IS_RELEASE" = "false" ]; then
          COMMIT_SHA=$(git rev-parse --short HEAD)
          SEMANTIC_VERSION="$VERSION+build.$BUILD_NUMBER.sha.$COMMIT_SHA"
        fi
        
        echo "Final version: $VERSION"
        echo "Semantic version: $SEMANTIC_VERSION"
        echo "Is release: $IS_RELEASE"
        
        # Set outputs
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "is-release=$IS_RELEASE" >> $GITHUB_OUTPUT
        echo "maven-version=$MAVEN_VERSION" >> $GITHUB_OUTPUT
        echo "git-tag=$GIT_TAG" >> $GITHUB_OUTPUT
        echo "build-number=$BUILD_NUMBER" >> $GITHUB_OUTPUT
        echo "semantic-version=$SEMANTIC_VERSION" >> $GITHUB_OUTPUT
        
        # Set environment variables for subsequent steps
        echo "VERSION=$VERSION" >> $GITHUB_ENV
        echo "IS_RELEASE=$IS_RELEASE" >> $GITHUB_ENV
        echo "BUILD_NUMBER=$BUILD_NUMBER" >> $GITHUB_ENV
        echo "SEMANTIC_VERSION=$SEMANTIC_VERSION" >> $GITHUB_ENV

    - name: Create Git tag for release
      id: create-tag
      shell: bash
      run: |
        VERSION="${{ steps.version-calc.outputs.version }}"
        IS_RELEASE="${{ steps.version-calc.outputs.is-release }}"
        AUTO_TAG="${{ inputs.auto-tag }}"
        
        if [ "$IS_RELEASE" = "true" ] && [ "$AUTO_TAG" = "true" ]; then
          echo "Release build detected - checking if tag should be created"
          
          # Check if tag already exists
          TAG_NAME="v$VERSION"
          if git tag -l | grep -q "^$TAG_NAME$"; then
            echo "Tag $TAG_NAME already exists, skipping tag creation"
            echo "tag-created=false" >> $GITHUB_OUTPUT
            echo "tag-name=$TAG_NAME" >> $GITHUB_OUTPUT
          else
            echo "Creating new tag: $TAG_NAME"
            
            # Configure git user for tagging
            git config --local user.email "action@github.com"
            git config --local user.name "GitHub Action"
            
            # Create annotated tag with release information
            git tag -a "$TAG_NAME" -m "Release version $VERSION

            Created by GitHub Actions
            Build: ${{ steps.version-calc.outputs.build-number }}
            Branch: ${{ github.ref_name }}
            Commit: ${{ github.sha }}
            Semantic Version: ${{ steps.version-calc.outputs.semantic-version }}"
                        
            echo "Tag $TAG_NAME created successfully"
            echo "tag-created=true" >> $GITHUB_OUTPUT
            echo "tag-name=$TAG_NAME" >> $GITHUB_OUTPUT
            
            # Set environment variable for subsequent steps
            echo "TAG_CREATED=true" >> $GITHUB_ENV
            echo "TAG_NAME=$TAG_NAME" >> $GITHUB_ENV
          fi
        else
          if [ "$IS_RELEASE" = "true" ]; then
            echo "Release build detected but auto-tagging is disabled"
            TAG_NAME="v$VERSION"
            echo "tag-created=false" >> $GITHUB_OUTPUT
            echo "tag-name=$TAG_NAME" >> $GITHUB_OUTPUT
          else
            echo "Development build - no tag will be created"
            echo "tag-created=false" >> $GITHUB_OUTPUT
            echo "tag-name=" >> $GITHUB_OUTPUT
          fi
          echo "TAG_CREATED=false" >> $GITHUB_ENV
        fi

    - name: Validate version
      shell: bash
      run: |
        VERSION="${{ steps.version-calc.outputs.version }}"
        echo "Validating version: $VERSION"
        
        # Basic version format validation
        if [[ ! "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+ ]]; then
          echo "Warning: Version does not follow semantic versioning pattern"
        else
          echo "Version format validation passed"
        fi
        
        # Check for SNAPSHOT in release builds
        if [ "${{ steps.version-calc.outputs.is-release }}" = "true" ] && [[ "$VERSION" == *"SNAPSHOT"* ]]; then
          echo "Error: Release build cannot have SNAPSHOT version"
          exit 1
        fi
        
        echo "Version validation completed successfully"

branding:
  icon: 'tag'
  color: 'green'
